#!/usr/bin/env ruby

# == Imports ================================================================

require 'optparse'
require 'thread'

require_relative '../lib/skein'

# == Support Classes ========================================================

class EchoReceiver < Skein::Receiver
  def initialize(options)
    @debug = options[:debug]
  end

  def echo(text)
    if (@debug)
      puts text
    end

    text
  end
end

# == Support Methods ========================================================

def rescue_safely(options)
  yield

rescue Object => e
  $stderr.puts('[%s] %s' % [ e.class, e ])

  if (options[:trace])
    $stderr.puts(e.backtrace)
  end

  exit(-1)
end

def in_thread(options)
  Thread.new do
    begin
      Thread.abort_on_exception = true

      rescue_safely(options) do
        yield
      end
    end
  end
end

# == Main ===================================================================

options = {
  count: 1,
  threads: 1
}

parser = OptionParser.new do |parser|
  parser.on('-v', '--verbose') do
    options[:verbose] = true
  end

  parser.on('-n', '--count=n') do |n|
    options[:count] = n.to_i
  end
  parser.on('-c', '--threads=n') do |n|
    options[:threads] = n.to_i
  end
  parser.on('-t', '--trace') do
    options[:trace] = true
  end
  parser.on('-d', '--debug') do
    options[:debug] = true
  end

  parser.on('-h', '--help') do
    puts parser
    exit(0)
  end
end

args = parser.parse(*ARGV)

case (args.shift)
when 'config'
  Skein::Support.hash_format(Skein.config).each do |line|
    puts line
  end
when 'test'
  rescue_safely(options) do
    Skein::RabbitMQ.connect

    puts '[OK] Connection succeeded.'
  end
when 'echo'
  rescue_safely(options) do
    conn = Skein::RabbitMQ.connect
    results = Queue.new

    start = Time.now

    count = Hash.new(0)

    tabulator = Thread.new do
      loop do
        v = results.pop

        break if (v.nil?)

        count[v] += 1
      end
    end

    options[:threads].times.map do
      in_thread(options) do
        ch = conn.create_channel

        queue = ch.queue('test_echo')

        client = Skein::Client.new(nil, queue)

        options[:count].times do |i|
          test_data = SecureRandom.uuid

          response = client.echo(test_data)

          results << (response == test_data)

          if (options[:verbose])
            puts '[%s] %s (%d/%d)' % [
              (response == test_data ? 'OK' : 'ERR'),
              response,
              i + 1,
              options[:count]
            ]
          end
        end

        client.cancel!

        ch.close
      end
    end.each(&:join)

    results << nil
    tabulator.join

    elapsed = Time.now - start

    puts 'Success: %d Failed: %d in %.1fms [%d mps]' % [
      count[true],
      count[false],
      elapsed.to_f * 1000,
      count[true] > 0 ? (count[true].to_f / elapsed.to_f) : 0
    ]

    conn.close
  end
when 'echo_server'
  rescue_safely(options) do
    conn = Skein::RabbitMQ.connect
    ch = conn.create_channel

    queue = ch.queue('test_echo')

    options[:threads].times.map do
      in_thread(options) do
        broker = Skein::Broker.new(EchoReceiver.new(options))
        broker.listen(ch, queue)
      end
    end.each(&:join)
  end
end
